import argparseimport loggingimport torchfrom gsBranch import arguments, scenefrom gsBranch.arguments import ModelParams, PipelineParams, OptimizationParamsfrom gsBranch.scene import Scene,GaussianModelfrom gsBranch.utils.general_utils import safe_statefrom gsBranch.arguments import ModelParams, PipelineParams, OptimizationParamsimport uuidfrom tqdm import tqdmfrom gsBranch.utils.image_utils import psnrimport sysimport osimport torchfrom random import randintfrom gsBranch.utils.loss_utils import l1_loss, ssimfrom gsBranch.gaussian_renderer import render, network_guidef parse_arguments():    """       Parses command line arguments.       This function uses the argparse library to define and parse command line arguments. It sets up several arguments,       including model parameters, optimization parameters, and pipeline parameters, as well as an argument for specifying       the data directory. After parsing the arguments, the function returns a namespace object containing all specified       arguments.       Returns:           args: A namespace object containing command line arguments.       """    # Initialize the command line argument parser    parser = argparse.ArgumentParser()    # Add model parameter configuration    lp = ModelParams(parser)    # Add optimization parameter configuration    op = OptimizationParams(parser)    # Add pipeline parameter configuration    pp = PipelineParams(parser)    # Define a command line argument for specifying the location of the data directory    parser.add_argument("--data_dir", type=str, default="./data/", help="data directory")    # 以下是3dgs中照搬的参数    parser.add_argument('--ip', type=str, default="127.0.0.1")    parser.add_argument('--port', type=int, default=6009)    parser.add_argument('--debug_from', type=int, default=-1)    parser.add_argument('--detect_anomaly', action='store_true', default=False)    parser.add_argument("--test_iterations", nargs="+", type=int, default=[7_000, 30_000])    parser.add_argument("--save_iterations", nargs="+", type=int, default=[7_000, 30_000])    parser.add_argument("--quiet", action="store_true")    parser.add_argument("--checkpoint_iterations", nargs="+", type=int, default=[])    parser.add_argument("--start_checkpoint", type=str, default=None)    # UDF中的参数    parser.add_argument('--conf', type=str, default='./confs/base.conf')    parser.add_argument('--mode', type=str, default='train')    parser.add_argument('--mcube_threshold', type=float, default=0.0025)    parser.add_argument('--is_continue', default=False, action="store_true")    parser.add_argument('--gpu', type=int, default=0)    parser.add_argument('--case', type=str, default='')    # parser.add_argument('--resolution', type=int, default=512)    parser.add_argument('--idx', type=int, default=-1)    parser.add_argument('--is_sequence', default=False, action='store_true')    parser.add_argument('--unit_sphere', default=False, action='store_true')    parser.add_argument('--rev_sequence', default=False, action='store_true')    parser.add_argument('--use_color', default=False, action='store_true')    # Parse the command line arguments and return    args = parser.parse_args(sys.argv[1:])    return args,lp,op,ppclass Trainer:    def __init__(self, args,lp,op,pp):        self.args = args        self.lp = lp        self.op = op        self.pp = pp    def training(        self, dataset, opt, pipe, testing_iterations, saving_iterations, checkpoint_iterations, checkpoint, debug_from    ):        # 应该通过sfm首先初始化点云，这个点云用作3dgs的训练        # TODO 或许这里可以换成SLAM来初始化点云（ https://github.com/yanyan-li/gaussian-splatting-using-PlanarSLAM?tab=readme-ov-file ），借鉴一下GeoGaussian        # TODO 也可以考虑用 COLMAP-FREE GS 来进行渲染？        first_iter = 0        # 初始化        # Gaussian model Initialization        gaussians = GaussianModel(dataset.sh_degree)        # 场景的数据加载        # 就是利用COLMAP的初始化        # 已经完成了点云初始化：            # 如果没有加载迭代模型，点云数据是从场景信息中复制并创建高斯模型            # 如果加载了迭代模型，则直接从模型路径加载点云文件初始化高斯模型        # 对象中存储了相机数据        scene = Scene(dataset, gaussians)        # 设置训练过程的初始化参数和优化器。        # 此方法根据传入的训练参数初始化对象的某些属性，并配置优化器以适应特定的学习率策略。        gaussians.training_setup(opt)        # 看本次运行的时候是不是从checkpoint来开始的，如果是，则加载checkpoint的时候的模型参数以及训练次数        if checkpoint:            (model_params, first_iter) = torch.load(checkpoint)            gaussians.restore(model_params, opt)        # 根据背景设置初始化背景色        bg_color = [1, 1, 1] if dataset.white_background else [0, 0, 0]        background = torch.tensor(bg_color, dtype=torch.float32, device="cuda")        # 初始化渲染的开始和结束事件，用于计算渲染时间        iter_start = torch.cuda.Event(enable_timing=True)        iter_end = torch.cuda.Event(enable_timing=True)        # 初始化 视图堆栈 和 训练日志的累积损失        viewpoint_stack = None        ema_loss_for_log = 0.0        # 设置进度条        progress_bar = tqdm(range(first_iter, opt.iterations), desc="Training progress")        first_iter += 1        # 两个网络先分开训练，然后在一些时候进行一个对另一个的指导，然后再在某个时候，反过来指导一次，后面再分开训练得到最终结果        for iter in range(first_iter, opt.iterations + 1):            passif __name__ == "__main__":    torch.set_default_tensor_type('torch.cuda.FloatTensor')    FORMAT = "[%(filename)s:%(lineno)s - %(funcName)20s() ] %(message)s"    logging.basicConfig(level=logging.DEBUG, format=FORMAT)    # 首先读取argumentss    args,lp,op,pp = parse_arguments()    args.save_iterations.append(args.iterations)    print("Optimizing " + args.model_path)    torch.cuda.set_device(args.gpu)    # Initialize system state (RNG)    safe_state(args.quiet)    torch.autograd.set_detect_anomaly(args.detect_anomaly)    # TODO Start GUI server, configure and run training    # network_gui.init(args.ip, args.port)    # 初始化trainer    trainer = Trainer(args,lp,op,pp)    # 前8个参数都是在3dgs中设置的    # UDF    trainer.training(lp.extract(args),                     op.extract(args),                     pp.extract(args),                     args.test_iterations,                     args.save_iterations,                     args.checkpoint_iterations,                     args.start_checkpoint,                     args.debug_from)